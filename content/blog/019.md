---js
const title = "In praise of the Unix Philosophy - 1"; const date = "2025-10-13T00:15:00-04:00"; const tags = ["software engineering", "philosophy"]; const draft = false;
---

The philosophy of Unix has elements of other timeless philosophies. One of them is that its principles match with the
principles of design of the underlying elements. That is, the software design principles of the Unix philosophy match
with the philosophy with which the underlying hardware is built.

If we observe the elements of the logic design of chips that run the software, we observe that one of the core principles on which
the chips are designed is that they take a lot of very simple elements and then glue them together in creative ways. That is,
it is the gluing that is difficult to understand, not the elements themselves. In the case of chips, the elements are the logic gates,
and by using a large number of them in creative ways, the logic design of chips is done. The logic gates themselves are, of course,
very easy to understand.

Let’s first observe the philosophy of logic gates:

1.	They do very simple computations. The AND, OR, and NOT gates all do very simple-to-understand computations.	
2.	They are easy to combine. It’s easy to combine logic gates to create complicated structures.
3.	Their inputs and outputs are simple to understand, i.e., the substructures of the complicated structures can be debugged.
They have at most two inputs and one output, all 0 or 1.

Now we can see how they match with the tenets of the Unix philosophy:
1.	**Do one thing and do it well**: Similar to the gates, i.e., the software tools themselves shouldn’t be doing too many things.
We can observe this clearly in GNU utilities.
2.	**Programs should work together**: Shell is the underlying glue in Unix. Powerful utilities like pipes let programmers
combine the software tools in creative ways to accomplish powerful computational tasks.
3.	**Text should be the universal interface of the programs**: This, just like logic gates, makes debugging substructures easier.
This is easy to see while debugging a Bash script. Since the inputs and outputs can be printed as text on the terminal,
having text as the interface makes debugging easier.

We see that there some similarities in the two philosophies.


